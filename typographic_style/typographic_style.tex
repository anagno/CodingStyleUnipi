\section{Στοιχεία καλού προγραμματιστικού στυλ}
Το καλό στυλ στην συγγραφή κώδικα είναι υποκειμενικό θέμα και είναι δύσκολο να προσδιοριστεί. Παρόλα αυτά, υπάρχουν πολλά στοιχεία που είναι κοινά σε ένα μεγάλο αριθμό από στυλ προγραμματισμού. Σε αυτή την ενότητα θα παρατεθούν αυτά ακριβώς τα στοιχεία.

\subsection{Τυπογραφικό στυλ - Εμφάνιση κώδικα}

Το προγραμματιστικό στυλ συνήθως ασχολείται και με την οπτική εμφάνιση του πηγαίου κώδικα, με στόχο να απαιτείται λιγότερη προσπάθεια από τους προγραμματιστές για την αναγνώριση και την εξαγωγή χρήσιμων πληροφοριών από τον κώδικα . Όταν το πρόγραμμα ολοκληρωθεί, σπάνια ένας προγραμματιστής θα το διαβάσει από πάνω προς τα κάτω. Στον εντοπισμό σφαλμάτων και στην βελτιστοποίηση του προγράμματος, οι προγραμματιστές παραλείπουν συχνά μεγάλα τμήματα του κώδικα, προκειμένου να βρουν αυτό που ψάχνουν. Μια καλή αναλογία είναι αν συγκριθεί ο πηγαίος κώδικας με ένα λεξικό. Αν οι λέξεις σε ένα λεξικό δεν ήταν σε αλφαβητική σειρά και με έντονη γραφή τότε ο εντοπισμός μιας συγκεκριμένης λέξης θα ήταν πολύ δύσκολος. Ομοίως λοιπόν και στον πηγαίο κώδικα, η οπτική εμφάνιση του κώδικα βοηθά στην μετέπειτα επεξεργασία του \cite{wiki:Programming_style,site:codding_matters}.

Το τυπογραφικό στυλ έχει αποδειχθεί ότι επηρεάζει την δυνατότητα κατανόησης του πηγαίου κώδικα και η συνεπής εφαρμογή κάποιου τυπογραφικού στυλ ενισχύει την κατανόηση ενός προγράμματος \cite{Mohan}.

\subsubsection{Εσοχές του κώδικα}

Οι εσοχές στον κώδικα βοηθούν στον προσδιορισμό της ροής του προγράμματος. Συγκεκριμένα οι εσοχές χρησιμοποιούνται για να επιτρέψουν στον αναγνώστη του κώδικα να καθορίσει το επίπεδο ένθεσης μίας δήλωσης με μία ματιά και για να οριοθετήσουν λογικά μπλοκ κώδικα. Για να είναι χρήσιμες, οι εσοχές πρέπει να είναι συνεπής και να χρησιμοποιείται πάντα ο ίδιος αριθμός σε όλο το πρόγραμμα (ή τουλάχιστον στο ίδιο αρχείο του προγράμματος). Συνήθως αναφέρονται ότι οι εσοχές πρέπει να είναι μεταξύ 2 και 5 κενών \cite{wiki:Programming_style,site:codding_matters,sutter2004c++}. Παρακάτω ακουλουθούν δύο παραδείγματα που στο ένα χρησιμοποιούνται εσοχές ενώ στο άλλο όχι:

\begin{lstlisting}[style=cpp,caption= Παράδειγμα εσοχών (1), label=program:indentation(1)]
if (hours < 24 && minutes < 60 && seconds < 60)
{
    return true;
}
else
{
    return false;
}
\end{lstlisting}

και 

\begin{lstlisting}[style=cpp,caption= Παράδειγμα εσοχών (2), label=program:indentation(2)]
if  ( hours   < 24
   && minutes < 60
   && seconds < 60
)
{return    true
;}         else
{return   false
;}
\end{lstlisting}

Το πρώτο παράδειγμα είναι πιο εύκολο να διαβαστεί μιας και κάθε λογικό κομμάτι του κώδικα ξεχωρίζει. Επομένως οι εσοχές στον κώδικα βοηθούν στις εμφολιασμένες εντολές.


\subsubsection{Κατακόρυφη στοίχιση}

Είναι συχνά χρήσιμο να στοιχίζονται κατακόρυφα παρόμοια στοιχεία, για να φαίνονται τα τυπογραφικά σφάλματα \cite{wiki:Programming_style}. Για παράδειγμα:

\begin{lstlisting}[style=cpp, caption= Κατακόρυφη στοίχιση (1), label=program:vertical_aligment(1)]
$search = array('a', 'b', 'c', 'd', 'e');
$replacement = array('foo', 'bar', 'baz', 'quux');
\end{lstlisting}
 
και

\begin{lstlisting}[style=cpp, caption= Κατακόρυφη στοίχιση (2), label=program:vertical_aligment(2)]
$search      = array('a',   'b',   'c',   'd',   'e');
$replacement = array('foo', 'bar', 'baz', 'quux');
\end{lstlisting}

Το τελευταίο παράδειγμα κάνει δύο πράγματα διαισθητικά σαφές που πριν δεν ήταν:

\begin{itemize}
\item οι μεταβλητές \en{search} και \en{replacement} σχετίζονται μεταξύ τους
\item και υπάρχει ένας παραπάνω όρος στην μεταβλητή \en{search} από ότι στην μεταβλητή \en{replacement}. Αν πρόκειται για κάποιο σφάλμα είναι πιο πιθανόν τώρα να εντοπιστεί.
\end{itemize}

Ωστόσο, σημειώνετε ότι υπάρχουν πολλά επιχειρήματα κατά της κατακόρυφης στοίχισης όπως:

\begin{description}
\item [Ευθραυστότητα: ] Εάν ένας προγραμματιστής κάνει κάποια αλλαγή στον "πίνακα" και δεν τον τακτοποιήσει, έχει ως αποτέλεσμα την επιδείνωση της οπτικής εμφάνισης των στοιχείων, που γίνεται ακόμα χειρότερη με κάθε αλλαγή και
\item [Δυσκολία στην συντήρηση: ] Η μορφοποίηση του πίνακα απαιτεί περισσότερη προσπάθεια για να διατηρηθεί.
\end{description}

\subsubsection{Διαστήματα}

Το στυλ που σχετίζονται με τα διαστήματα \footnote{Τα κενά (διαστήματα), τα \en{tabs} και οι νέες γραμμές (αλλαγή γραμμής) ονομάζονται διαστήματα.} χρησιμοποιούνται για την ενίσχυση της αναγνωσιμότητας του πηγαίου κώδικα. Δεν υπάρχουν γνωστές μελέτες οι οποίες υποστηρίζουν ότι τα διαστήματα βοηθούν στην αναγνωσιμότητα του κώδικα αλλά από μία απλή σύγκριση του παρακάτω κώδικά φαίνεται ότι αμυδρά βοηθά στην καλύτερη κατανόηση του κώδικα. Για παράδειγμα \cite{wiki:Programming_style}: 

\begin{lstlisting}[style=cpp, caption= Διαστήματα (1), label=program:spaces(1)]
int i;
for(i=0;i<10;++i){
    printf("%d",i*i+i);
}
\end{lstlisting}

έναντι

\begin{lstlisting}[style=cpp, caption= Διαστήματα (2), label=program:spaces(2)]
int i;
for( i = 0; i < 10; ++i ) {
    printf( "%d", i * i + i );
}
\end{lstlisting}

Η χρήση των διαστημάτων στον πηγαίο κώδικα είναι όμοια με τους κανόνες της αγγλικής γλώσσας. Αυτό σημαίνει ότι \cite{site:codding_matters}:

\begin{enumerate}
\item Τα περισσότερα βασικά σύμβολα στις γλώσσες προγραμματισμού (π.χ. "=", "+", κ.λ.π.) θα πρέπει να έχουν τουλάχιστον ένα διάστημα πριν και ένα διάστημα μετά από αυτούς με τις παρακάτω εξαιρέσεις:
  \begin{enumerate}
  \item Δεν εμφανίζεται διάστημα πριν από κόμμα ή πριν από ερωτηματικό.
  \item Δεν εμφανίζεται διάστημα πριν ή μετά από τελεία.
  \item Δεν εμφανίζεται διάστημα μεταξύ των δυαδικών τελεστών (π.χ. "->", "++").
  \end{enumerate}
\item Περισσότερα από ένα κενά μπορούν να χρησιμοποιηθούν για την ευθυγράμμιση στοιχείων (όπως στην κατακόρυφη στοίχιση).
\item Κενές γραμμές θα πρέπει ακόμα να χρησιμοποιούνται για να τον διαχωρισμό λογικών μπλοκ κώδικάς, όπως
  \begin{enumerate}
  \item Στο αρχή του πηγαίου κώδικα όπου υπάρχουν οι ντιρεκτίβες \en{include, const, typedef} κ.λ.π. .
  \item και σε κομμάτια κώδικα που είναι εκτεταμένα και υπάρχουν μέσα τους ξεχωριστά τμήματα κώδικα και μπορούν να διαχωριστούν με μία κενή γραμμή.
  \end{enumerate}
\end{enumerate}


\subsubsection{Αγκύλες}

Στις γλώσσες προγραμματισμού που επιτρέπουν αγκύλες, έχει καταστεί κοινή πρακτική να χρησιμοποιούνται ακόμα και όταν η χρήση τους δεν είναι απαραίτητη. Η χρήση τους επιτρέπεται σε όλους τους βρόγχους επανάληψης και δομές ελέγχου. Για παράδειγμα:

\begin{lstlisting}[style=cpp, caption= Αγκύλες (1), label=program:brackets(1)]
for (i = 0 to 5) {
  print i * 2;
}
 
print "Ended loop";
\end{lstlisting}

Με την χρήση των αγκυλών αποτρέπονται λογικά σφάλματα, τα οποία συνήθως είναι και χρονοβόρα να εντοπιστούν, όπως όταν ένα ερωτηματικό τερματισμού εισάγεται κατά λάθος στον πηγαίο κώδικα (Αλγόριθμος \ref{program:brackets(2)})

\begin{lstlisting}[style=cpp, caption= Αγκύλες (2), label=program:brackets(2)]
 for (i = 0; i < 5; ++i);
    printf("\%d \n", i*2);    /* The incorrect indentation hides the fact 
                               that this line is not part of the loop body. */

 printf("Ended loop");
\end{lstlisting}

 
Ένα παρόμοιο λάθος είναι όταν προστίθεται μια επιπλέον γραμμή πριν την πρώτη γραμμή (αλγόριθμος \ref{program:brackets(3)})

\begin{lstlisting}[style=cpp, caption= Αγκύλες (3), label=program:brackets(3)]
 for (i = 0; i < 5; ++i)
    printf(logfile, "loop reached %d\n", i);
    printf("%d\n", i*2);    /* The incorrect indentation hides the fact 
                               that this line is not part of the loop body. */
  printf("Ended loop");
\end{lstlisting}

Γι` αυτό το λόγο έχει καθιερωθεί η χρήση των αγκυλών όπως στον αλγόριθμο \ref{program:brackets(4)}.
%An alternate and more traditional style is to explicitly indicate the nesting. This means that the opening and closing braces are in the same column:

\begin{lstlisting}[style=cpp, caption= Αγκύλες (4), label=program:brackets(4)]
for( index = 0 ; index < size ; ++index )
{
    arrayA[ index ] = arrayB[ index ] ;
}
\end{lstlisting}

Στον αλγόριθμο \ref{program:brackets(4)} φαίνεται σαφώς τόσο η αρχή όσο και το τέλος τους μπλοκ εντολών. Υπάρχουν και άλλες μεθοδολογίες τοποθέτησης των αγκυλών (όπως π.χ. η αρχική αγκύλη να μπαίνει αμέσως μετά την βρόγχο επανάληψης όπως και στον αλγόριθμο \ref{program:brackets(1)}) οι οποίες δεν διαφέρουν από τον τρόπο που περιγράφτηκε στον παραπάνω αλγόριθμο. Η μικροδιαφορές αυτές δεν επηρεάζουν την αναγνωσιμότητα του κώδικα αλλά θα πρέπει να υπάρχει συνέπεια στην χρήση των αγκυλών \cite{sutter2004c++}.

%\subsubsection{Στοίχιση και ευθυγράμμιση του κώδικα}

%Συμπυκνώνοντας λοιπόν τα άνωθεν έχουμε το παρακάτω παράδειγμα:

%\begin{lstlisting}[style=cpp, caption= Στοίχιση και ευθυγράμμιση του κώδικα (1), label=program:lining(1)]
%for(i=0;i<s;i++){a[i]=b[i];}
%\end{lstlisting}

%Ο στοιχισμένος κώδικας:

%\begin{lstlisting}[style=cpp, caption= Στοίχιση και ευθυγράμμιση του κώδικα (2), label=program:lining(2)]
%for( index = 0 ; index < size ; index++ )
%{
%    arrayA[ index ] = arrayB[ index ] ;
%}
%\end{lstlisting}

%Όπως παρατηρούμε, μπορεί ο καθένας να σαρώσει τον κώδικα και να δει τα μοτίβα που υπάρχουν στον κώδικα. Αυτό είναι πολύ σημαντικό, όχι μόνο για την κατανόηση του κώδικα, αλλά και για την εύρεση σφαλμάτων. Ο κώδικας που έχει πολλές περιττές παραλλαγές, είναι ο κώδικας στον οποίο χάνετε πολύ χρόνος εργασίας.
